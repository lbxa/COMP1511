{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red0\green0\blue120;\red0\green0\blue0;
}
{\*\expandedcolortbl;;\csgenericrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c54510;\cssrgb\c0\c0\c0;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl440\sa298\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 The effects of web compilers to the stack\cf4 \cb1 \uc0\u8232 
\i\b0\fs24 Don't trust web compilers where you're analysing the stack
\i0 \
\pard\pardeftab720\sl280\sa240\partightenfactor0
\cf4 Whilst printing out the code to the screen describing the locations of the variables int the memory, it became apparent that the values were beginning at the higher order values.\
This was an unusual behaviour as the stack begins at the bottom of the memory and works its way up.\
\pard\pardeftab720\sl260\sa332\partightenfactor0

\b\fs20 \cf4 Data Types\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\b0\fs24 \cf4 All of the data types being signed, unsigned or neither still had the same amount of bytes. This was significant as I had previously thought that signed numbers would require an extra bit to locate the negative sign. With further research this can also be achieved by a principle called the two's compliment. This is a strategy for computers to be able to deal with negative numbers without needing a negative sign. \uc0\u8232 \
Also the size of the variables did vary depending on the data type and machine's architecture, mine being a 64 bit machine had more space to store the data in the SRAM. I did specify a -m32 argument to the GCC compiler to compile it with a 32 bit architecture, this again made the space for the data smaller. \uc0\u8232 \
When I tried to access an address that I hadn't assigned in my program, (in didn't belong to me) I sometimes got a segmentation fault, but more often I would get very arbitrary numbers printed out to the screen. This is know as memory exploitation or stack overflows. Index's and addresses must be set explicitly so this can be prevented from happening in a normal program or application. \uc0\u8232 \
\pard\pardeftab720\sl280\sa120\partightenfactor0
\cf4 \
\pard\pardeftab720\sl280\sa240\partightenfactor0
\cf4 In summary, normal compilers cause the stack frame to work its way up, while the heap frame works its way down, every data type being signed or unsigned will be the same amount of bytes (they are unsigned as default).\
}